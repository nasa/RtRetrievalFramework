# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _luabind_object.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_luabind_object')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_luabind_object')
    _luabind_object = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_luabind_object', [dirname(__file__)])
        except ImportError:
            import _luabind_object
            return _luabind_object
        try:
            _mod = imp.load_module('_luabind_object', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _luabind_object = swig_import_helper()
    del swig_import_helper
else:
    import _luabind_object
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except __builtin__.Exception:
    weakref_proxy = lambda x: x


SHARED_PTR_DISOWN = _luabind_object.SHARED_PTR_DISOWN

def _new_from_init(cls, version, *args):
    '''For use with pickle, covers common case where we just store the
    arguments needed to create an object. See for example HdfFile'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__(*args)
    return inst

def _new_from_set(cls, version, *args):
    '''For use with pickle, covers common case where we use a set function 
    to assign the value'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__()
    inst.set(*args)
    return inst

import full_physics_swig.state_vector
class LuaCallback(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, Ls):
        if self.__class__ == LuaCallback:
            _self = None
        else:
            _self = self
        _luabind_object.LuaCallback_swiginit(self, _luabind_object.new_LuaCallback(_self, Ls))
    __swig_destroy__ = _luabind_object.delete_LuaCallback
    def __disown__(self):
        self.this.disown()
        _luabind_object.disown_LuaCallback(self)
        return weakref_proxy(self)
LuaCallback.call = new_instancemethod(_luabind_object.LuaCallback_call, None, LuaCallback)
LuaCallback.__str__ = new_instancemethod(_luabind_object.LuaCallback___str__, None, LuaCallback)
LuaCallback_swigregister = _luabind_object.LuaCallback_swigregister
LuaCallback_swigregister(LuaCallback)


class LuaCallbackWrap(LuaCallback):
    def __init__(self,ls,f):
       LuaCallback.__init__(self, ls)
       self.ls = ls
       self.f = f
       t = inspect.getargspec(f)[0]
       self.narg = len(t)
       if(self.narg > 0 and t[0] == 'self'):
         self.narg = self.narg - 1
       if(self.narg > 10):
         raise "We only support up to 10 argument in a function. This limitation comes from luabind"

    def call(self,obj1, obj2, obj3, obj4, obj5, obj6, obj7, obj8, obj9,
             obj10):
       if(self.narg == 0):
         t = self.f()
       elif(self.narg == 1):
         t = self.f(obj1.cast_type())
       elif(self.narg == 2):
         t = self.f(obj1.cast_type(), obj2.cast_type())
       elif(self.narg == 3):
         t = self.f(obj1.cast_type(), obj2.cast_type(), obj3.cast_type())
       elif(self.narg == 4):
         t = self.f(obj1.cast_type(), obj2.cast_type(), obj3.cast_type(),
                    obj4.cast_type())
       elif(self.narg == 5):
         t = self.f(obj1.cast_type(), obj2.cast_type(), obj3.cast_type(),
                    obj4.cast_type(), obj5.cast_type())
       elif(self.narg == 6):
         t = self.f(obj1.cast_type(), obj2.cast_type(), obj3.cast_type(),
                    obj4.cast_type(), obj5.cast_type(), oj6.cast_type())
       elif(self.narg == 7):
         t = self.f(obj1.cast_type(), obj2.cast_type(), obj3.cast_type(),
                    obj4.cast_type(), obj5.cast_type(), obj6.cast_type(),
                    obj7.cast_type())
       elif(self.narg == 8):
         t = self.f(obj1.cast_type(), obj2.cast_type(), obj3.cast_type(),
                    obj4.cast_type(), obj5.cast_type(), obj6.cast_type(),
                    obj7.cast_type(), obj8.cast_type())
       elif(self.narg == 9):
         t = self.f(obj1.cast_type(), obj2.cast_type(), obj3.cast_type(),
                    obj4.cast_type(), obj5.cast_type(), obj6.cast_type(),
                    obj7.cast_type(), obj8.cast_type(), obj9.cast_type())
       elif(self.narg == 10):
         t = self.f(obj1.cast_type(), obj2.cast_type(), obj3.cast_type(),
                    obj4.cast_type(), obj5.cast_type(), obj6.cast_type(),
                    obj7.cast_type(), obj8.cast_type(), obj9.cast_type().
                    obj10.cast_type())
       else:
         raise "This shouldn't be able to happen"

       if(t == None):
           return LuabindObject.nil(self.ls)

       elif(isinstance(t, dict)):
           new_table = LuabindObject.nil(self.ls).new_table()
           for t_key, t_val in t.items():
              new_table[t_key] = t_val
           return LuabindObject(self.ls, new_table)

       elif(isinstance(t, list) or isinstance(t, tuple)):
           new_table = LuabindObject.nil(self.ls).new_table()
           for t_idx, t_val in enumerate(t):
               new_table[t_idx+1] = t_val
           return LuabindObject(self.ls, new_table)

       else:
         return LuabindObject(self.ls, t)


import inspect

class LuabindIterator(object):
    """

    This is a light wrapper around the luabind::iterator.

    This adds a few convenience routines to make usage in Python much
    easier.

    C++ includes: luabind_object.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, Lbo, Ls):
        """

        FullPhysics::LuabindIterator::LuabindIterator(const LuabindObject &Lbo, const boost::shared_ptr< LuaState > &Ls)
        Constructor. 
        """
        _luabind_object.LuabindIterator_swiginit(self, _luabind_object.new_LuabindIterator(Lbo, Ls))

    def at_end(self):
        """

        bool FullPhysics::LuabindIterator::at_end() const

        """
        return _luabind_object.LuabindIterator_at_end(self)


    def key(self):
        """

        LuabindObject FullPhysics::LuabindIterator::key() const

        """
        return _luabind_object.LuabindIterator_key(self)


    def next(self):
        """

        LuabindObject FullPhysics::LuabindIterator::next()

        """
        return _luabind_object.LuabindIterator_next(self)

    __swig_destroy__ = _luabind_object.delete_LuabindIterator
LuabindIterator.at_end = new_instancemethod(_luabind_object.LuabindIterator_at_end, None, LuabindIterator)
LuabindIterator.key = new_instancemethod(_luabind_object.LuabindIterator_key, None, LuabindIterator)
LuabindIterator.next = new_instancemethod(_luabind_object.LuabindIterator_next, None, LuabindIterator)
LuabindIterator_swigregister = _luabind_object.LuabindIterator_swigregister
LuabindIterator_swigregister(LuabindIterator)

class LuabindObject(object):
    """

    This is a light wrapper around the luabind::object.

    This adds a few convenience routines.

    C++ includes: luabind_object.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def is_nil(self):
        """

        bool FullPhysics::LuabindObject::is_nil() const
        Test type of an object. 
        """
        return _luabind_object.LuabindObject_is_nil(self)


    def is_boolean(self):
        """

        bool FullPhysics::LuabindObject::is_boolean() const

        """
        return _luabind_object.LuabindObject_is_boolean(self)


    def is_number(self):
        """

        bool FullPhysics::LuabindObject::is_number() const

        """
        return _luabind_object.LuabindObject_is_number(self)


    def is_string(self):
        """

        bool FullPhysics::LuabindObject::is_string() const

        """
        return _luabind_object.LuabindObject_is_string(self)


    def is_table(self):
        """

        bool FullPhysics::LuabindObject::is_table() const

        """
        return _luabind_object.LuabindObject_is_table(self)


    def is_function(self):
        """

        bool FullPhysics::LuabindObject::is_function() const

        """
        return _luabind_object.LuabindObject_is_function(self)


    def length(self, index=0):
        """

        int FullPhysics::LuabindObject::length(int index=0) const
        Return the "length" of the value at the given index using the Lua
        interpreter method that evaluates as the length operator. 
        """
        return _luabind_object.LuabindObject_length(self, index)


    def call(self, *args):
        """

        LuabindObject FullPhysics::LuabindObject::call(const T1 &Arg1, const T2 &Arg2, const T3 &Arg3, const T4 &Arg4, const
        T5 &Arg5, const T6 &Arg6, const T7 &Arg7, const T8 &Arg8)

        """
        return _luabind_object.LuabindObject_call(self, *args)


    def lua_state(self):
        """

        const boost::shared_ptr<LuaState>& FullPhysics::LuabindObject::lua_state() const
        Lua state pointer.

        You can use this to do things with luabind (or directly with Lua) that
        this class doesn't already support. 
        """
        return _luabind_object.LuabindObject_lua_state(self)


    def object(self):
        """

        const luabind::object& FullPhysics::LuabindObject::object() const

        """
        return _luabind_object.LuabindObject_object(self)


    def new_table(self):
        """

        LuabindObject FullPhysics::LuabindObject::new_table()
        Creates a new table object. 
        """
        return _luabind_object.LuabindObject_new_table(self)


    def nil(Ls):
        """

        static LuabindObject FullPhysics::LuabindObject::nil(const boost::shared_ptr< LuaState > &Ls)
        Return a nil value. 
        """
        return _luabind_object.LuabindObject_nil(Ls)

    nil = staticmethod(nil)

    def value_generic_object(self):
        """

        boost::shared_ptr< GenericObject > LuabindObject::value_generic_object() const
        Return value as a GenericObject, or return a null pointer if we can't
        convert to a GenericObject.

        This is useful for use with Python. 
        """
        return _luabind_object.LuabindObject_value_generic_object(self)


    def set_value(self, *args):
        """

        void FullPhysics::LuabindObject::set_value(const std::string &Vname, const LuabindObject &V)

        """
        return _luabind_object.LuabindObject_set_value(self, *args)


    def set_index(self, *args):
        """

        void FullPhysics::LuabindObject::set_index(int Vidx, const LuabindObject &V)

        """
        return _luabind_object.LuabindObject_set_index(self, *args)


    def __init__(self, *args):
        """

        FullPhysics::LuabindObject::LuabindObject(const boost::shared_ptr< LuaState > &Ls, const LuabindObject &V)

        """
        _luabind_object.LuabindObject_swiginit(self, _luabind_object.new_LuabindObject(*args))

    def get_index(self, Vidx):
        """

        LuabindObject FullPhysics::LuabindObject::get_index(int Vidx) const

        """
        return _luabind_object.LuabindObject_get_index(self, Vidx)


    def cast_type(self):
        '''Cast to underlying type'''
        t = "Types"
        if(self.is_nil()):
            return None
        v = self.value_generic_object()
        if(v is not None):
            return v
        elif(self.is_boolean()):
            return self.getbool()
        elif(self.is_number()):
            return self.getnum()
        elif(self.is_string()):
            return self.getstring()
        elif(self.is_table()):
            return self
        elif(self.is_function()):
            return self
        elif(self.isblitzarray1d_double()):
            return self.getblitzarray1d_double()
        elif(self.isblitzarray2d_double()):
            return self.getblitzarray2d_double()
        elif(self.isblitzarray1d_bool()):
            return self.getblitzarray1d_bool()
        elif(self.isvector_altitude()):
            return self.getvector_altitude()
        return self

    def __getitem__(self, key):
        if isinstance(key, int):
            return self.get_index(key).cast_type()
        else:
            return self.get_string(key).cast_type()

    def __setitem__(self, key, v):
    # Set up which set method to use
        if(isinstance(key, int)):
            if key <= 0:
                raise ValueError("Lua integer indexing is 1 based, not 0 based")
            set_method = self.set_index
        else:
            set_method = self.set_value

    # Perform any value specific work
        if(not isinstance(v, LuabindObject) and hasattr(v, '__call__')):
            set_method(key, LuaCallbackWrap(self.lua_state(), v))

        elif(isinstance(v, bool)):
            if(isinstance(key, int)):
                set_method = self.set_index_bool
            else:
                set_method = self.set_value_bool
            set_method(key, v)

        elif(isinstance(v, dict)):
            new_table = self.new_table()
            for v_key, v_val in v.items():
               new_table[v_key] = v_val
            set_method(key, new_table)

        elif(isinstance(v, list) or isinstance(v, tuple)):
    # Only support assigining lists or tuples for now,
    # since so many other objects are iterable but
    # need to be set differently, for instance LuabindObject
    # itself is iterable
            new_table = self.new_table()
            for v_idx, v_val in enumerate(v):
               new_table[v_idx+1] = v_val
            set_method(key, new_table)
        else:
            set_method(key, v)

    def __getattr__(self, key):
        return self[key]

    def __setattr__(self, key, v):
        if(key == "this"):
            self.__dict__[key] = v
        else:
            self[key] = v



    def __call__(self, *args):
        luargs = []
        luargs2 = []
        for a in args:
            if(isinstance(a, LuabindObject)):
               t = a
            else:
               t = LuabindObject(self.lua_state(), a)
            luargs.append(t)
            luargs2.append(t.object())
        return self.call(*luargs2).cast_type()

    def __len__(self):
        return self.cast_type().length()

    def __iter__(self):
        if(self.is_table()):
            def luabind_gen():
                lb_iter = LuabindIterator(self, self.lua_state())
                while not lb_iter.at_end():
                    yield lb_iter.next().cast_type()
            return luabind_gen()
        else:
            raise TypeError("Can not iterate on non table LuabindObject")

    def __dir__(self):
        if(self.is_table()):
            obj_contents = []
            lb_iter = LuabindIterator(self, self.lua_state())
            while not lb_iter.at_end():
                key_item = lb_iter.key().cast_type()
    # Only add strings to dir() listing,
    # because in Lua arrays would have numeric
    # keys and these are not accessible through
    # getattr
                if isinstance(key_item, str):
                    obj_contents.append( key_item  )
                lb_iter.next()
            return obj_contents
        else:
            item = self.cast_type()
    # Try not to engage in infinite recursion!
            if isinstance(item, LuabindObject):
                return []
            else:
                return dir(item)

    __swig_destroy__ = _luabind_object.delete_LuabindObject
LuabindObject.__str__ = new_instancemethod(_luabind_object.LuabindObject___str__, None, LuabindObject)
LuabindObject.is_nil = new_instancemethod(_luabind_object.LuabindObject_is_nil, None, LuabindObject)
LuabindObject.is_boolean = new_instancemethod(_luabind_object.LuabindObject_is_boolean, None, LuabindObject)
LuabindObject.is_number = new_instancemethod(_luabind_object.LuabindObject_is_number, None, LuabindObject)
LuabindObject.is_string = new_instancemethod(_luabind_object.LuabindObject_is_string, None, LuabindObject)
LuabindObject.is_table = new_instancemethod(_luabind_object.LuabindObject_is_table, None, LuabindObject)
LuabindObject.is_function = new_instancemethod(_luabind_object.LuabindObject_is_function, None, LuabindObject)
LuabindObject.length = new_instancemethod(_luabind_object.LuabindObject_length, None, LuabindObject)
LuabindObject.call = new_instancemethod(_luabind_object.LuabindObject_call, None, LuabindObject)
LuabindObject.lua_state = new_instancemethod(_luabind_object.LuabindObject_lua_state, None, LuabindObject)
LuabindObject.object = new_instancemethod(_luabind_object.LuabindObject_object, None, LuabindObject)
LuabindObject.new_table = new_instancemethod(_luabind_object.LuabindObject_new_table, None, LuabindObject)
LuabindObject.value_generic_object = new_instancemethod(_luabind_object.LuabindObject_value_generic_object, None, LuabindObject)
LuabindObject.isvector_altitude = new_instancemethod(_luabind_object.LuabindObject_isvector_altitude, None, LuabindObject)
LuabindObject.getvector_altitude = new_instancemethod(_luabind_object.LuabindObject_getvector_altitude, None, LuabindObject)
LuabindObject.isblitzarray1d_double = new_instancemethod(_luabind_object.LuabindObject_isblitzarray1d_double, None, LuabindObject)
LuabindObject.getblitzarray1d_double = new_instancemethod(_luabind_object.LuabindObject_getblitzarray1d_double, None, LuabindObject)
LuabindObject.isblitzarray2d_double = new_instancemethod(_luabind_object.LuabindObject_isblitzarray2d_double, None, LuabindObject)
LuabindObject.getblitzarray2d_double = new_instancemethod(_luabind_object.LuabindObject_getblitzarray2d_double, None, LuabindObject)
LuabindObject.isblitzarray1d_bool = new_instancemethod(_luabind_object.LuabindObject_isblitzarray1d_bool, None, LuabindObject)
LuabindObject.getblitzarray1d_bool = new_instancemethod(_luabind_object.LuabindObject_getblitzarray1d_bool, None, LuabindObject)
LuabindObject.set_value = new_instancemethod(_luabind_object.LuabindObject_set_value, None, LuabindObject)
LuabindObject.set_index = new_instancemethod(_luabind_object.LuabindObject_set_index, None, LuabindObject)
LuabindObject.set_value_bool = new_instancemethod(_luabind_object.LuabindObject_set_value_bool, None, LuabindObject)
LuabindObject.set_index_bool = new_instancemethod(_luabind_object.LuabindObject_set_index_bool, None, LuabindObject)
LuabindObject.get_string = new_instancemethod(_luabind_object.LuabindObject_get_string, None, LuabindObject)
LuabindObject.get_index = new_instancemethod(_luabind_object.LuabindObject_get_index, None, LuabindObject)
LuabindObject.getbool = new_instancemethod(_luabind_object.LuabindObject_getbool, None, LuabindObject)
LuabindObject.getnum = new_instancemethod(_luabind_object.LuabindObject_getnum, None, LuabindObject)
LuabindObject.getstring = new_instancemethod(_luabind_object.LuabindObject_getstring, None, LuabindObject)
LuabindObject_swigregister = _luabind_object.LuabindObject_swigregister
LuabindObject_swigregister(LuabindObject)

def LuabindObject_nil(Ls):
    """

    static LuabindObject FullPhysics::LuabindObject::nil(const boost::shared_ptr< LuaState > &Ls)
    Return a nil value. 
    """
    return _luabind_object.LuabindObject_nil(Ls)



